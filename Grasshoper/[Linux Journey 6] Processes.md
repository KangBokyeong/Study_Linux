# [Linux Journey 6] Processes
## ps(Processes)
- 컴퓨터에서 실행중인 프로그램.
- 커널에 의해 관리되며 각 프로세스는 프로세스 ID (PID)와 관련된 ID가 있음.
  - PID는 프로세스가 생성된 순서대로 할당 됨.
- ps 명령어를 실행하면 실행 중인 프로세스의 목록 확인 가능(다음 아래 표는 예시임)

  |PID|TTY|STAT|TIME|CMD|
  |:-----:|:-----:|:-----:|:-----:|:-----:|
  | 41230  |  pts/4 |  Ss  |  00:00:00 |  bash |
  | 51224  |  pts/4 |  R+  |  00:00:00 |   ps  |

  - PID: 프로세스 ID
  - TTY: 프로세스와 연관된 제어 단자
  - STAT: 프로세스 상태 코드
  - TIME: CPU의 총 사용 시간
  - CMD: 실행 파일 / 명령의 이름

- ps aux 명령어 실행 중 aux 각각의 의미
  - a: 다른 사용자에 의해 실행되는 것을 포함하여 실행중인 모든 프로세스 표시
  - u: 프로세스에 대한 자세한 내용 표시
  - x: TTY가없는 모든 프로세스 나열
- 앞으로 다룰 내용
  - USER: 유효 사용자 (우리가 사용하는 액세스 권한이있는 사용자)
  - %CPU: 사용 된 CPU 시간을 프로세스가 실행 된 시간으로 나눈 값
  - %MEM: 프로세스의 상주 세트 크기와 시스템의 실제 메모리의 비율
  - VSZ: 전체 프로세스의 가상 메모리 사용
  - RSS(Resident set size):  작업에서 사용한 스왑되지 않은 물리적 메모리
  - TTY: 프로세스와 연관된 제어 단자
  - STAT: 프로세스 상태 코드
  - START: 프로세스의 시작 시간
  - TIME: CPU의 총 사용 시간
  - COMMAND: 실행 파일 / 명령의 이름
 
  - 가장 많이 볼 수 있는 필드: PID, STAT 및 COMMAND

- top 명령어: 스냅샷 대신 시스템에서 실행중인 프로세스에 대한 실시간 정보 제공

## Controlling Terminal
- TTY: 명령을 실행한 처미널
- regular terminal devices 와 pseudoterminal devices
  - regular terminal device: 입력해서 시스템에 출력을 보낼 수 있는 네이티브 터미널 장치
    - segue를 사용하여 이 동작을 볼 수 있음.
    - Ctrl-Alt-F1을 입력하여 TTY1(첫 번째 가상 콘솔)에 들어가고 터미널, 그래픽이 없는 경우를 확인.
    - Ctrl-Alt-F7로 종료.
  - pseudoterminal devices: 쉘 창으로 단말기를 모방하고 PTS에 의해 표시

## Process Details
- 프로세스의 자세한 정보: 프로그램을 실행하기 위해 메모리, CPU, I/O를 할당하는 시스템
- 커널: 프로세스 담당. 프로그램 실행 시 프로그램 코드를 메모리에 로드, 리소스 결정, 할당한 뒤 각 프로세스의 지속적인 모니터링
  - 프로세스 상태
  - 프로세스가 사용 중이고 받는 리소스
  - 프로세스 소유자
  - 신호 처리
  - 그리고 기본적으로 다른 모든 것들
  - 커널의 일: 프로세스 수요에 따라 적절한 양의 자원을 얻는 것.
  - 프로세스 종료 시, 다른 프로세스를 위해 사용한 리소스가 확보됨.

## Process Creation
- 새로운 프로세스 생성 시, 기존 프로세스는 기본적으로 포크 시스템 호출이라는 것을 사용하여 복제됨.
  - 포크 시스템 호출 -> 대부분 동일한 자식 프로세스 생성.
  - 자식 프로세스 -> 새로운 프로세스 ID(PID)를 사용하여 원래 프로세스는 부모 프로세스가 됨.
  - 부모 프로세스 ID PPID라고 하는 것을 가짐.
- 이후 자식 프로세스는 무모가 이전에 사용하던 것과 동일한 프로그램을 계속 사용하거나, 새로운 프로그램을 시작하기 위해  execve system 호출을 더 자주 사용할 수 있음.
  - 시스템 호출 -> 커널이 해당 프로세스에 사용한 메모리 관리 파괴, 새로운 프로그램을 위해 새로운 메모리 설정
- ps l 명령어를 입력하여 동작 알아가보기
  - l: 실행 중인 프로세스에 대한 long format(긴 형식) 또는 훨씬 더 자세한 보기 제공 

## Process Termination
- 프로세스 종료 시, _exit system 호출을 사용하여 종료
- 어떤 과정이 종료될 준비가 되면, 그것은 왜 그것이 종료 상태라고 불리는 것으로 끝나는지를 커널에 알려줌.
- 가장 일반적인 상태: 프로세스가 성공했음을 의미
- 자식 프로세스가 종료해야지만 부모 프로세스를 종료할 수 있음.(대기 시스템 호출을 사용하여 자식 프로세스의 종료 승인)

### 프로세스 종료 시 두 가지 방법
- Orphan Processes
  - 부모 프로세스가 자식 프로세스 전에 종료되면 커널은 대기 전화를 받지 않을 것이라는 것을 알고 있으므로, 대신 이러한 프로세스를 "고정"하게 하고 초기 단계의 관리 하에 둠
  -  Init은 결국 이 고아들이 죽을 수 있도록 대기 시스템 호출을 수행할 것임.

- Zombie Processes
  - 기술적으로 '죽음'이기 때문에 죽일 수 없음.
  - 부모가 대기 시스템을 호출하면 좀비는 사라질 것이고, 이것은 "복제"라고 알려져 있음.
  - 이 프로세스가 많은 경우는 공간을 차지하기 때문에 많은 것은 좋지 않음.

## Signals
- 어떤 일이 일어났음을 프로세스에 알림
### 신호가있는 이유
- 용도
  - 사용자는 특수 터미널 문자 (Ctrl-C) 또는 (Ctrl-Z) 중 하나를 입력하여 프로세스를 중지, 중단 또는 일시 중단 가능
  - 하드웨어 문제가 발생할 수 있으며 커널이 프로세스에 알리고 싶어함.
  - 소프트웨어 문제가 발생할 수 있으며 커널이 프로세스에 알리고 싶어함.
  - 기본적으로 프로세스가 통신 할 수 있는 방법
  
### 신호 처리
- 신호가 어떤 이벤트에 의해 생성되면 프로세스에 전달되고 전달 될 때까지 보류 상태로 간주됨.
- 프로세스 실행 시 신호 전달
- 프로세스에는 신호 마스크가 있으며 지정된 경우 신호 전달을 차단하도록 설정 가능
  -  신호 무시
  - 신호를 "캐치 (Catch)"하고 특정 처리기 루틴 수행
  - 정상 종료 시스템 호출과 달리 프로세스 종료 가능
  - 신호 마스크에 따라 신호 차단

### 공통 신호
- 각 신호는 SIGxxx 형식의 기호 이름을 가진 정수로 정의됨.
- 가장 일반적인 신호 중 일부:
  - SIGHUP or HUP or 1: 전화 끊기
  - SIGINT or INT or 2: 인터럽트
  - SIGKILL or KILL or 9: Kill
  - SIGSEGV or SEGV or 11: 세그먼트 오류
  - SIGTERM or TERM or 15: 소프트웨어 종료
  - SIGSTOP or STOP: 중지
- 숫자는 신호에 따라 다를 수 있으므로 일반적으로 이름 참조

## kill (Terminate)
- 프로세스를 종료시키는 신호
- 명령어: kill
- 예시
  > kill 12445
  - 12445는 종료 시키고 싶은 프로세스의 PID.
  - SIGTERM 시그널은 프로세스가 자원을 깔끔하게 해제하고 상태를 저장하는 것을 허용함으로써 종료를 요청하는 프로세스로 보내짐.
  
  > kill -9 12445
  - kill 명령어를 사용하여 신호 지정
  - SIGKILL 신호가 실행되고 프로세스 종료

### SIGHUP, SIGINT, SIGTERM, SIGKILL, SIGSTOP의 차이점은 무엇입니까?
- SIGHUP: Hangup. 제어 터미널이 닫힐 때 프로세스로 보내짐. 
  > 예를 들어, 프로세스가 실행중인 터미널 창을 닫은 경우 SIGHUP 신호를 받게 됨. 

- SIGINT: 인터럽트 신호이므로 Ctrl-C를 사용하면 시스템이 정상적으로 프로세스를 종료하려고 시도함.

- SIGTERM: 프로세스를 종료 시키지만 먼저 정리를 수행하도록 허용 권장.
- SIGKILL: 프로세스를 종료하고, 불로 죽이고, 정리를하지 않음.
- SIGSTOP: 프로세스 중지 / 일시 중단

## niceness
- 프로세스가 CPU에 대한 우선 순위를 결정하는 번호를 가지고 있음을 의미 함.
  - 높은 숫자: 프로세스가 훌륭하고 CPU의 우선 순위가 낮음을 의미
  - 낮은 숫자 or 음수: 프로세스가 좋지 않고 가능한 한 많은 CPU를 확보하고자 함을 의미

- niceness 레벨 변경 시 nice 및 renice 명령 사용
  > nice -n 5 apt upgrade
  - nice: 새 프로세스의 우선 순위를 설정하는데 사용
  > renice 10 -p 3245
  - renice:  기존 프로세스의 우선 순위를 설정하는데 사용

## Process States
- ps aux 명령을 사용하여 프로세스 상태 나타내기
- STAT 열에는 많은 값이 표시됨. 
- 가장 보편적인 상태 코드:
  - R: 실행 또는 실행 가능, CPU에서 처리 대기
  - S: 터미널로부터의 입력과 같은 이벤트가 완료될 때까지 대기하는 중단 없는 절전
  - D: 무정전 잠 (uninterruptible sleep), 신호로 사망하거나 중 단할 수없는 프로세스, 대개 멀리 떨어지게하려면 재부팅하거나 문제를 해결해야함.
  - Z: 좀비
  - T: 중지됨, 일시 중지 / 중지 된 프로세스

## /proc filesystem
- 커널이시스템을 보는 방법
- ls /proc 명령을 실행하면,
  - 모든 PID에 대한 하위 디렉토리가 있음.
  - ps 출력에서 PID를 찾으면 / proc 디렉토리에서 찾을 수 있음.
- 프로세스 중 하나를 입력하고 해당 파일을 살펴 보기
  - 예시
    > cat /proc/12345/status
    - 프로세스 상태 정보와 더 자세한 정보가 표시됨.
- ps에서 볼 수있는 것보다 훨씬 많은 정보가 있음.

##  Job Control 
- 프로세스를 작업과 함께 실행하는 방법 제어

### 백그라운드로 작업 보내기
- 명령에 엠퍼샌드(&) 추가 시, 백그라운드에서 실행됨.
  
  |예시|
  |:-----:|
  |sleep 1000 &|
  ||
  |sleep 1001 &|
  ||
  |sleep 1002 &|

### 모든 백그라운드 작업보기

- jobs 명령어 입력 시 아래 결과 출력.
  
  |예시|
  |:-----:|
  |[1]    Running     sleep 1000 &|
  ||
  |[2]-   Running     sleep 1001 &|
  ||
  |[3]+   Running     sleep 1002 &|

  - ID가 첫 번째 열에 표시되고 상태 및 실행 된 명령이 표시됨.
  - 작업 ID 옆의 +는 시작한 가장 최근의 백그라운드 작업임을 나타냄.
  - -가있는 작업은 두 번째 가장 최근 명령어.

### 기존 작업에서 백그라운드로 작업 보내기
- 먼저 Ctrl-Z로 작업을 일시 중단 한 다음 bg 명령을 실행하여 백그라운드로 보냅

|예시1|
|:-----:|
|pete@icebox ~ $ sleep 1003|
||
|^Z|
||
|[4]+    Stopped     sleep 1003|

|예시2|
|:-----:|
|pete@icebox ~ $ bg|
||
|[4]+    sleep 1003 &|

|예시3|
|:-----:|
|pete@icebox ~ $ jobs|
||
|[1]    Running     sleep 1000 &|
||
|[2]    Running     sleep 1001 &|
||
|[3]-   Running     sleep 1002 &|
||
|[4]+   Running     sleep 1003 &|

### 백그라운드에서 포 그라운드로 작업 이동
- 원하는 작업 ID 지정
- 옵션없이 fg를 실행하면 가장 최근의 백그라운드 작업 (그 옆에 +기호가있는 작업)이 나타남.
- 예시
  > fg %1

### 백그라운드 작업 삭제
- 작업 ID를 사용하여 프로세스 종료
- 예시
  > kill %1
